class Shadow {

  PVector[] corners;

  Shadow(PVector[] co) {
    corners = co;
  }

  void drawShape() {
    noStroke();
    //  drawShape(0, 100);
    drawShape(0, 255);
  }

  void drawShape(int shade, int alpha) {
    //  outline
    for (int i = 0; i < corners.length; i++) {
      PVector c1 = corners[i];
      PVector c2 = corners[(i+1) % corners.length];  //  use mod to get 0 on length to avoid out of bounds
      line(c1.x, c1.y, c2.x, c2.y);
    }
    //  fill in (with triangles)
    fill(shade, alpha);
    noStroke();
    for (int i = 1; i < corners.length-1; i++) {
      PVector c1 = corners[i];
      PVector c2 = corners[(i+1) % corners.length];  //  use mod to get 0 on length to avoid out of bounds
      triangle(corners[0].x, corners[0].y, c1.x, c1.y, c2.x, c2.y);
    }
    stroke(0);
  }
}



//  same as shadow, but no center

class ShadowShape extends Shadow {

  PVector center;

  ShadowShape(PVector[] co, PVector ce) {
    super(co);
    center = ce;
  }

  //  returns all of the shadows generated by the shape
  //  works by getting each line segment and creating a quad based on that segment and the edge
  ArrayList<Shadow> shadows(PVector light) {

    ArrayList<Shadow> shadows = new ArrayList<Shadow>();

    for (int i = 0; i < corners.length; i++) {
      PVector c1 = corners[i];
      PVector c2 = corners[(i+1) % corners.length];  //  use mod to get 0 on length to avoid out of bounds

      stroke(255, 0, 0);
      line(light.x, light.y, center.x, center.y);
      println(lineLineSegmentIntersection(light, center, c1, c2));
      stroke(0);

      //  check if the line segment between the flashlight and the center does not intersect the side
      if (!(lineLineSegmentIntersection(light, center, c1, c2))) {
        //  create shape intersect

        //  check based on light and center position which walls the shadow will hit
        //  if they interact with the same 2 walls, use points of furthest wall
        //  if different walls, use common wall

        /*
        walls:
         __________
         |    0    |
         | 3     1 |
         |____2____|
         */

        int[] wall1 = {0, 0, 0, 0};
        if (c1.y < light.y)
          wall1[0]++;
        if (c1.x > light.x)
          wall1[1]++;
        if (c1.y > light.y)
          wall1[2]++;
        if (c1.x < light.x)
          wall1[3]++;

        int[] wall2 = {0, 0, 0, 0};
        if (c2.y < light.y)
          wall2[0]++;
        if (c2.x > light.x)
          wall2[1]++;
        if (c2.y > light.y)
          wall2[2]++;
        if (c2.x < light.x)
          wall2[3]++;


        if (i == 0) {
          println(wall1);
          println(wall2);
        }

        /*

         boolean useClosest = false;
         
         PVector[] wallCorners = {new PVector(0, 0), new PVector(width, 0), new PVector(width, height), new PVector(0, height)};
         
         PVector inter1a = null;
         PVector inter1b = null; 
         for (int j = 0; j < wall1.length; j++) {
         if (wall1[j] > 0) {
         if (inter1a == null)
         inter1a = lineIntersection(wallCorners[j], wallCorners[(j+1)%4], c1, light);
         else
         inter1b = lineIntersection(wallCorners[j], wallCorners[(j+1)%4], c1, light);
         }
         }
         if (inter1b != null) {
         if (dist(inter1a.x, inter1a.y, c1.x, c1.y) < dist(inter1b.x, inter1b.y, c1.x, c1.y))
         inter1a = inter1b.copy();
         }
         
         PVector inter2a = null;
         PVector inter2b = null; 
         for (int j = 0; j < wall2.length; j++) {
         if (wall2[j] > 0) {
         if (inter2a == null)
         inter2a = lineIntersection(wallCorners[j], wallCorners[(j+1)%4], c2, light);
         else
         inter2b = lineIntersection(wallCorners[j], wallCorners[(j+1)%4], c2, light);
         }
         }
         if (inter2b != null) {
         if (dist(inter2a.x, inter2a.y, c2.x, c2.y) < dist(inter2b.x, inter2b.y, c2.x, c2.y)) 
         inter2a = inter2b.copy();
         }
         
         if (i == 0) {
         println(inter1a);
         println(inter2a);
         }
         */

        //  PVector inter1a = c1.copy().add(c1.copy().sub(light.copy()));
        //  PVector inter2a = c2.copy().add(c2.copy().sub(light.copy()));
        PVector inter1a = c1.copy().add((c1.copy().sub(light.copy())).normalize().mult(max(width, height)*2));
        PVector inter2a = c2.copy().add((c2.copy().sub(light.copy())).normalize().mult(max(width, height)*2));

        PVector[] c = {c1.copy(), c2.copy(), inter2a.copy(), inter1a.copy()};
        Shadow s = new Shadow(c);
        shadows.add(s);
      }
    }


    return shadows;
  }

  void drawShape() {
    drawShape(0, 0);
    //  draw center
    fill(0);
    ellipse(center.x, center.y, 2, 2);
  }
}




class Octagon extends ShadowShape {

  Octagon(PVector center, int diameter) {

    super(new PVector[0], center);

    /*
    side length = s
     d = s + 2*root(2)*s
     d = (1+2*root(2))*s
     s = diameter/(1+2*root(2))
     */
    float s = diameter/(1+sqrt(2));
    /*
   .      0___1
     .   /     \
     .  7       2
     .  |       |
     .  6       3
     .   \     /
     .    5---4
     */
    s = s/2;  //  use half since we need the distance from the center (middle) to end of side
    float r = diameter/2;  //  use half since we need the distance from the center (middle) to end of side
    PVector[] c = {
      new PVector(center.x-s, center.y-r), 
      new PVector(center.x+s, center.y-r), 
      new PVector(center.x+r+1, center.y-s), //  added 1 so not perfectly vertical line
      new PVector(center.x+r, center.y+s), 
      new PVector(center.x+s, center.y+r), 
      new PVector(center.x-s, center.y+r), 
      new PVector(center.x-r+1, center.y+s), //  added 1 so not perfectly vertical line
      new PVector(center.x-r, center.y-s)
    };
    corners = c;  //  overwrite currently empty corners array
  }
}
